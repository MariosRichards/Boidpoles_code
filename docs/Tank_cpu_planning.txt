ATRobots language grammar

1. Remarks - drop (;)
2. Directives? var defs?
	- why bother having declarations?
	- precompiled machine code - DITCH
Compile directives:
	#TIME : maximum timeslice (i.e. could be lower than global) - DITCH
	#MSG  : some text under name - LATER
	#CONFIG: ROBOT CONFIGURATION - DEFINITELY
	12 points
	so ... first 12 elements state where the points go?
	- downside, you can't have more than 5 in any section (just ignore if go above that?)
	
	
3. Labels? 
	(a) Indirect :(0-32767) - don't use same number twice
	(b) Direct   !labels - don't become lines ... DITCH!
4. Commands
5. Variables (up to 256, 16 bits -32768, 32767)





COMMANDS
========
Drop
= [43, 44, 46, 32]

Minimise misses by modulo-ing into range (i.e. values can be in range whatever, but forced into the range of the commands)

PORTS
=====

Minimise misses by modulo-ing into range (i.e. values can be in range whatever, but forced into the range of the commands)
Some of those could be compressed to give more I/O (e.g. spedometer/set throttle)

INTERRUPTS
==========

Ignore for the moment
<Can be implemented later>

MEMORY MAP
==========


CONSTANTS
=========



ERRORS
======







Design "compiled code" for ease of use in program
We'll be "compiling" robot code into the "compiled code" in any case


Don't worry about V/N - make different codes for each?
N -> V and N
V -> V


Only issue
-> no support for self-modifying code

@123 @124 @125
-> Would not allow this!


Choices
(1) one command per V/N combination, specifies how next operands are to be interpreted
(2) first bit of operand tells you whether it's a value or a variable (values then have to be 15bit)

Dumbest option is (1)



How to deal with variable and label use?
Don't worry


Tank_cpu

	memory[1024]
	program[???]
	ip

BORING JOBS
(1) Add all commands
(2) Add all timings to array
	
	

Things to implement entire thing

(0)
   Make cpu cycles persistent (i.e. 40 cpu cycle command make you start next turn at -35 and skip until positive)

(1) Is there an easy way to handle all cpu time costs?

 it's zero
 or it's some fixed number based only on cmd
 or it's some IPO/OPO/INT declaration

 laziest option
 if cmd not in IPO/OPO/INT:
	key = cmd
 else:
	key = 100*cmd + op1
	
	
 key = cmd
 if key in timings_array:
	time += timings_array[key[
 else:
    zero_time ++
	
	if not, then 0
 elif cmd * 100 + op1 not in
 
 
(2) Do I *really* want to implement multiple versions of commands for various combinations of V/N?

-> just make a function and hand in the necessary values

-> Better yet, do the symbolic manipulation at the beginning
Then mod 63

Just double-check ordered combinations 
scale unambiguously with number of 64s



Ports

Num:  T:  I/O Name:             Function:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  1   0    I  Spedometer        Returns current throttle setting[-75- 100]
  2   0    I  Heat Sensor       Returns current heat-level       [0 - 500]
  3   0    I  Compass           Returns current heading          [0 - 255]
  4   0    I  Turret Sensor     Returns current turret offset    [0 - 255]
  5   0    I  Turret Sensor     Returns absolute turret heading  [0 - 255]
  6   0    I  Damage Sensor     Returns current armor level      [0 - 100]
  7   1    I  Scanner           Returns range to nearest target in scan arc
  8   1    I  Accuracy          Returns accuracy of last scan     [-2 - 2]
  9   3    I  Radar             Returns range to nearest target
 10   0    I  Random Generator  Returns random number     [-32768 - 32767]
 11   0    O  Throttle          Sets throttle                  [-75 - 100]
 12   0    O  Rotate Turret     Offsets turret (cumulative)
 13   0    O  Aim Turret        Sets turret offset to value      [0 - 255]
 14   0    O  Steering          Turn specified number of degrees
 15   3    O  Weapon control    Fires weapon w/ angle adjustment  [-4 - 4]
 16  40    I  Sonar             Returns heading to nearest target[0 - 255]
 17   0   I/O Scan-Arc          Sets/Returns scan-arc width.      [0 - 64]
 18   0   I/O Overburn          Sets/Returns overburn status
 19   0   I/O Transponder       Sets/Returns current transponder ID
 20   0   I/O Shutdown-Level    Sets/Returns shutdown-level.
 21   0   I/O Com Channel       Sets/Returns com channel setting
 22   0   I/O Mine Layer        Lays mine or Returns mines-remaining.
 23   0   I/O Mine Trigger      Detonates/returns previously-placed mines.
 24   0   I/O Shield            Sets/Returns shield's status (0=off, else=on)



Commands:

 0  1  NOP           NOP        Simply wastes a clock-cycle.
 1  1  ADD           ADD V N    Adds      V+N, result stored in V
 2  1  SUB           SUB V N    Subtracts V-N, result stored in V
33  1  INC           INC V      Increments V, (v=v+1)
34  1  DEC           DEC V      Decrements V, (v=v-1)
35  1  SHL           SHL V N    Bit-shifts  V left  N bit positions
36  1  SHR           SHR V N    Bit-shifts  V right N bit positions
37  1  ROL           ROL V N    Bit-rotates V left  N bit positions
38  1  ROR           ROR V N    Bit-rotates V right N bit positions

45  1  NEG           NEG V      Negates V:   V = 0-V  (aka "two's compliment")
 3  1  OR            OR  V N    Bitwise OR,  V or  N, result stored in V
 4  1  AND           AND V N    Bitwise AND, V and N, result stored in V
 5  1  XOR           XOR V N    Bitwise XOR, V xor N, result stored in V
 6  1  NOT           NOT V      Bitwise NOT, not(V),  result stored in V
 7 10  MPY           MPY V N    Mulitplies V*N, result stored in V
 8 10  DIV           DIV V N    Divides    V/N, result stored in V (integer)
 9 10  MOD           MOD V N    MOD's    V & N, result stored in V (modulus)
 
10  1  RET  RETURN   RET        Returns from a subroutine (pops the ip)
11  1  CALL GSB      CALL N     Calls subroutine at label #N (pushes ip)
12  1  JMP  GOTO     JMP N      Jumps program (ip) to label #N

20  1  CMP           CMP N N    Compares two numbers, results in flags reg.
13  0  JLS  JB       JLS N      Jumps to label N if last compare was <
14  0  JGR  JA       JGR N      Jumps to label N if last compare was >
15  0  JNE           JNE N      Jumps to label N if last compare was <>
16  0  JEQ  JE       JEQ N      Jumps to label N if last compare was =
41  0  JAE  JGE      JAE N      Jumps to label N if last compare was >=
42  0  JBE  JLE      JBE N      Jumps to label N if last compare was <=
39  0  JZ            JZ  N      Jumps to label N if last compare was 0
40  0  JNZ           JNZ N      Jumps to label N if last compare was not 0

17  3  XCHG SWAP     XCHG V V   Exchanges the values of two variables
18  1  DO            DO N       Sets CX = N
19  1  LOOP          LOOP N     Decrements CX, If CX>0 then Jumps to label N
21  2  TEST          TEST N N   Ands two numbers, result not stored, flags set
22  1  MOV  SET      MOV V N    Sets V = N

23  2  LOC  ADDR     LOC V V    Sets first V = memory address of second V
24  2  GET           GET V N    Sets V = number from memory location N
25  2  PUT           PUT N1 N2  Sets memory location N2 = N1

26  ?  INT           INT N      Executes interrupt number N
27  4+ IPO  IN       IPO N V    Inputs number from port N, result into V
28  4+ OPO  OUT      OPO N1 N2  Outputs N2 to port N1

29  ?  DEL  DELAY    DEL N      Equivelant to N NOPS.

30  1  PUSH          PUSH N     Puts N onto the stack (sp incremented)
31  1  POP           POP  V     Removes a number from the stack, into V

32  0  ERR  ERROR    ERR N      Generate an error code, useful for debugging















N = number, of any type. Could be a number or value from a variable.
 V = variable, meaning it must be a variable, register, or memory access.

 In the chart header below, T refers to the time it takes to execute
an instruction

Op: T: Name: Alt:    Syntax/Description:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 0  1  NOP           NOP        Simply wastes a clock-cycle.
 1  1  ADD           ADD V N    Adds      V+N, result stored in V
 2  1  SUB           SUB V N    Subtracts V-N, result stored in V
33  1  INC           INC V      Increments V, (v=v+1)
34  1  DEC           DEC V      Decrements V, (v=v-1)
35  1  SHL           SHL V N    Bit-shifts  V left  N bit positions
36  1  SHR           SHR V N    Bit-shifts  V right N bit positions
37  1  ROL           ROL V N    Bit-rotates V left  N bit positions
38  1  ROR           ROR V N    Bit-rotates V right N bit positions
43  1  SAL           SAL V N    Bit-Shifts, same as SHL
44  1  SAR           SAR V N    Same as SHR, except preserves bit 15.
45  1  NEG           NEG V      Negates V:   V = 0-V  (aka "two's compliment")
 3  1  OR            OR  V N    Bitwise OR,  V or  N, result stored in V
 4  1  AND           AND V N    Bitwise AND, V and N, result stored in V
 5  1  XOR           XOR V N    Bitwise XOR, V xor N, result stored in V
 6  1  NOT           NOT V      Bitwise NOT, not(V),  result stored in V
 7 10  MPY           MPY V N    Mulitplies V*N, result stored in V
 8 10  DIV           DIV V N    Divides    V/N, result stored in V (integer)
 9 10  MOD           MOD V N    MOD's    V & N, result stored in V (modulus)
10  1  RET  RETURN   RET        Returns from a subroutine (pops the ip)
11  1  CALL GSB      CALL N     Calls subroutine at label #N (pushes ip)
12  1  JMP  GOTO     JMP N      Jumps program (ip) to label #N
20  1  CMP           CMP N N    Compares two numbers, results in flags reg.
13  0  JLS  JB       JLS N      Jumps to label N if last compare was <
14  0  JGR  JA       JGR N      Jumps to label N if last compare was >
15  0  JNE           JNE N      Jumps to label N if last compare was <>
16  0  JEQ  JE       JEQ N      Jumps to label N if last compare was =
41  0  JAE  JGE      JAE N      Jumps to label N if last compare was >=
42  0  JBE  JLE      JBE N      Jumps to label N if last compare was <=
39  0  JZ            JZ  N      Jumps to label N if last compare was 0
40  0  JNZ           JNZ N      Jumps to label N if last compare was not 0
46  1  JTL           JTL N      Jumps to line N of compiled program.
17  3  XCHG SWAP     XCHG V V   Exchanges the values of two variables
18  1  DO            DO N       Sets CX = N
19  1  LOOP          LOOP N     Decrements CX, If CX>0 then Jumps to label N
21  2  TEST          TEST N N   Ands two numbers, result not stored, flags set
22  1  MOV  SET      MOV V N    Sets V = N
23  2  LOC  ADDR     LOC V V    Sets first V = memory address of second V
24  2  GET           GET V N    Sets V = number from memory location N
25  2  PUT           PUT N1 N2  Sets memory location N2 = N1
26  ?  INT           INT N      Executes interrupt number N
27  4+ IPO  IN       IPO N V    Inputs number from port N, result into V
28  4+ OPO  OUT      OPO N1 N2  Outputs N2 to port N1
29  ?  DEL  DELAY    DEL N      Equivelant to N NOPS.
30  1  PUSH          PUSH N     Puts N onto the stack (sp incremented)
31  1  POP           POP  V     Removes a number from the stack, into V
32  0  ERR  ERROR    ERR N      Generate an error code, useful for debugging
